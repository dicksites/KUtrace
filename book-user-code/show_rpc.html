<html>
<meta charset="UTF-8">
<!-- Copyright 2021 Richard L. Sites -->

<head>
 
<style> /* set the CSS */
 
.verticalline {
  fill: none;
  stroke: #600090;
  stroke-width: 1px;
}
.verticaldashline {
  fill: none;
  stroke: #600090;
  stroke-width: 1px;
  stroke-dasharray: 2,4;
}

.rubberline {
  fill: none;
  stroke: #600090;
  stroke-width: 4px;
}


.markertext {
  text-anchor: left;
  font-family: sans-serif; 
  fill: #600090;
}

.rubbertext {
  text-anchor: middle;
  font-family: sans-serif; 
  fill: #600090;
}
 
.graphline {
  fill: none;
  stroke: steelblue;
  stroke-width: 2px;
}
 
/* .axis { font-size: 12px; } */
.tick { font-size: 15px; font-family: sans-serif; }
 
</style>
 
 
<!-- Load the d3.js library -->    	
<!-- selfcontained0 -->
<script src="https://d3js.org/d3.v4.min.js"></script>


<script type="text/javascript">
<!-- selfcontained1 --> 


//----------------------------------------------------------------------------//
// Global constants                                                           //
//----------------------------------------------------------------------------//
 
var minslop_sec = 0.000005;	// At least 5 usec on each end of a transmission

// Dummy data to show when there is a missing file name
// 999.0 is end marker; will be popped off before use
var dummyData = {
  "axisLabelX" : " ",
  "axisLabelY" : " ",
  "shortMulX" : 1,
  "shortUnitsX" : "s",
  "thousandsX" : 1000,
  "title" : "File not found",
  "tracebase" : " ",
  "events" : [[0, 0, 0, 0, 0, 0, 0, 0, 0, "x"], 
              [999.0, 0, 0, 0, 0, 0, 0, 0, 0, "x"]]
};

// Little usage hints to display
var usage_text = "Scroll wheel to zoom. Click-drag to pan. " + 
  "Shift-click-unclick to annotate. " + 
  "Shift-click-unshift to annotate and keep. " + 
  "Shift-click-drag to measure. Red dot resets.";

var usage_text_empty = "";

// For buttons
var kActiveBackColor = "#F0F0FF";	// very light blue
var kActiveBorderColor = "#0000FF";	// blue
var kActiveTextColor = "#000080";	// dark blue

var kInactiveBackColor = "#FFFFFF";	// white
var kInactiveBorderColor = "#C0C0C0";	// light gray
var kInactiveTextColor = "#000000";	// black

var kUnuseableColor = "#E0E0E0";	// very light gray

var normalcolor = {
  color1: [
    "#CC0000", "#CC4700", "#CC8F00", "#BECC00", "#77CC00", 
    "#30CC00", "#00CC18", "#00CC5F", "#00CCA7", "#00A7CC", 
    "#005FCC", "#0018CC", "#3000CC", "#7700CC", "#BE00CC", 
    "#CC008F", "#CC0047" 
  ],

  color2: [
    "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00", 
    "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
    "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066" 
  ],

  gray1: [
    "#959595", "#aeaeae", "#c8c8c8", "#dddddd", "#d5d5d5", 
    "#cecece", "#c9c9c9", "#cccccc", "#cecece", "#c2c2c2", 
    "#a8a8a8", "#8f8f8f", "#8c8c8c", "#939393", "#9b9b9b", 
    "#9a9a9a", "#989898"
  ],

  gray2: [
    "#9b9b9b", "#bfbfbf", "#e3e3e3", "#f0f0f0", "#e5e5e5", 
    "#dadada", "#dedede", "#e2e2e2", "#d2d2d2", "#adadad", 
    "#898989", "#949494", "#9e9e9e", "#a2a2a2", "#9e9e9e" 
  ],

  mod1: 17,
  mod2: 15
};

// Experiment: just swap reg and green
var colorblindcolor1 = {
  color1: [
    "#00CC00", "#47CC00", "#8FCC00", "#CCBE00", "#CC7700", 
    "#CC3000", "#CC0018", "#CC005F", "#CC00A7", "#A700CC", 
    "#5F00CC", "#1800CC", "#0030CC", "#0077CC", "#00BECC", 
    "#00CC8F", "#00CC47" 
  ],

  color2: [
    "#00FF00", "#66FF00", "#CCFF00", "#FFCC00", "#FF6600", 
    "#FF0000", "#FF0066", "#FF00CC", "#CC00FF", "#6600FF", 
    "#0000FF", "#0066FF", "#00CCFF", "#00FFCC", "#00FF66" 
  ],

  gray1: [
    "#959595", "#aeaeae", "#c8c8c8", "#dddddd", "#d5d5d5", 
    "#cecece", "#c9c9c9", "#cccccc", "#cecece", "#c2c2c2", 
    "#a8a8a8", "#8f8f8f", "#8c8c8c", "#939393", "#9b9b9b", 
    "#9a9a9a", "#989898"
  ],

  gray2: [
    "#9b9b9b", "#bfbfbf", "#e3e3e3", "#f0f0f0", "#e5e5e5", 
    "#dadada", "#dedede", "#e2e2e2", "#d2d2d2", "#adadad", 
    "#898989", "#949494", "#9e9e9e", "#a2a2a2", "#9e9e9e" 
  ],

  mod1: 17,
  mod2: 15
};

// Experiment 2: rotate rgb colors to brg
var colorblindcolor = {
  color1: [
    "#00CC00", "#00CC47", "#00CC8F", "#00BECC", "#0077CC", 
    "#0030CC", "#1800CC", "#5F00CC", "#A700CC", "#CC00A7", 
    "#CC005F", "#CC0018", "#CC3000", "#CC7700", "#CCBE00", 
    "#8FCC00", "#47CC00" 
  ],

  color2: [
    "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
    "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066", 
    "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00" 
  ],

  gray1: [
    "#959595", "#aeaeae", "#c8c8c8", "#dddddd", "#d5d5d5", 
    "#cecece", "#c9c9c9", "#cccccc", "#cecece", "#c2c2c2", 
    "#a8a8a8", "#8f8f8f", "#8c8c8c", "#939393", "#9b9b9b", 
    "#9a9a9a", "#989898"
  ],

  gray2: [
    "#9b9b9b", "#bfbfbf", "#e3e3e3", "#f0f0f0", "#e5e5e5", 
    "#dadada", "#dedede", "#e2e2e2", "#d2d2d2", "#adadad", 
    "#898989", "#949494", "#9e9e9e", "#a2a2a2", "#9e9e9e" 
  ],

  mod1: 17,
  mod2: 15
};



// This product includes color specifications and designs developed by 
// Cynthia Brewer (http://colorbrewer2.org/). 

var colorblindcolorx = {
  color1: [
    '#d73027','#f46d43','#fdae61','#fee090','#ffffbf',
    '#e0f3f8','#abd9e9','#74add1','#4575b4'
  ],

  color2: [	// Darkened by 3/4 from the originals
    '#581f62', '#836992', '#ad9fae', '#b9b9b9', '#a2b49e', 
    '#5f8f5c', '#145a29'
  ],

  gray1:  [
    "#a9a9a9", "#c2c2c2", "#dcdcdc", "#f0f0f0", "#fcfcfc", 
    "#f7f7f7", "#e7e7e7", "#d1d1d1", "#b7b7b7"
  ],

  gray2:  [ 
    "#979797", "#b8b8b8", "#d1d1d1", "#dcdcdc", "#d7d7d7", 
    "#c0c0c0", "#a3a3a3"
  ], 

  mod1: 9,
  mod2: 7
};


// HSB(n mod 17, 1.0, 0.8)  top/middle, no white
var color17 = [
  "#CC0000", "#CC4700", "#CC8F00", "#BECC00", "#77CC00", 
  "#30CC00", "#00CC18", "#00CC5F", "#00CCA7", "#00A7CC", 
  "#005FCC", "#0018CC", "#3000CC", "#7700CC", "#BE00CC", 
  "#CC008F", "#CC0047", 
];

// HSB(n mod 15, 1, 1)  bottom/outer, no white
var color15 = [
  "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00", 
  "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
  "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066", 
];


// unknown: light yellow, fault: light red, interrupt: light blue, syscall: light green
var kernelcolor = [
  "#FFFFE0", "#FFFFE0", "#FFFFE0", "#FFFFE0", 
  "#FFC0C0", "#C0C0FF", "#FFC0C0", "#C0C0FF",  
  "#E0FFE0", "#E0FFE0", "#E0FFE0", "#E0FFE0", 
  "#E0FFE0", "#E0FFE0", "#E0FFE0", "#E0FFE0", 
  ];

var kernelgray = [
//var kernelcolor = [
  "#fdfdfd", "#fdfdfd", "#fdfdfd", "#fdfdfd", 
  "#e6e6e6", "#e2e2e2", "#e6e6e6", "#e2e2e2", 
  "#fafafa", "#fafafa", "#fafafa", "#fafafa", 
  "#fafafa", "#fafafa", "#fafafa", "#fafafa" 

//  "#fcfcfc", "#fcfcfc", "#fcfcfc", "#fcfcfc", 
//  "#cdcdcd", "#c4c4c4", "#cdcdcd", "#c4c4c4", 
//  "#f6f6f6", "#f6f6f6", "#f6f6f6", "#f6f6f6", 
//  "#f6f6f6", "#f6f6f6", "#f6f6f6", "#f6f6f6"
  ];

 

// unknown:  yellow, fault:  red, interrupt:  blue, syscall:  green
var darkkernelcolor = [
  "#FFFF70", "#FFFF70", "#FFFF70", "#FFFF70", 
  "#FF6060", "#6060FF", "#FF6060", "#6060FF",  
  "#70FF70", "#70FF70", "#70FF70", "#70FF70", 
  "#70FF70", "#70FF70", "#70FF70", "#70FF70", 
  ];

var darkkernelgray = [
//var darkkernelcolor = [
 "#f9f9f9", "#f9f9f9", "#f9f9f9", "#f9f9f9", 
  "#c0c0c0", "#b5b5b5", "#c0c0c0", "#b5b5b5", 
  "#eaeaea", "#eaeaea", "#eaeaea", "#eaeaea", 
  "#eaeaea", "#eaeaea", "#eaeaea", "#eaeaea" 

//  "#f4f4f4", "#f4f4f4", "#f4f4f4", "#f4f4f4", 
//  "#818181", "#6b6b6b", "#818181", "#6b6b6b", 
//  "#d6d6d6", "#d6d6d6", "#d6d6d6", "#d6d6d6", 
//  "#d6d6d6", "#d6d6d6", "#d6d6d6", "#d6d6d6" 
  ];

var prefixCpu = 0;
var prefixPid = 1;
var prefixRpc = 2;
var prefixRes = 3;

var textmultiplier_tbl = [1.0, 0.75, 1.5, 1.25];

var kFromBase40 = "_abcdefghijklmnopqrstuvwxyz0123456789-./";



// Set the initial margins of the graph
var margin = {top: 20, right: 20, bottom: 50, left: 70, diagramtop: 20, diagrambottom: 50};
 
// Set the margins of the SVG area
var winMargin = {width: 10, height: 40};	// Room for borders and File: box

// Room for top/bottom HTML. These fit snuggly for Chrome, but run over for Safari
// Altered in initializeState if needed
var winMargin2 = {top:40, top2x: 60, bottom:50, bottom2x: 70, left:15, right:15, width1: 1100};	


// Click to toggle 0/max
// Shift-click to cycle 0 max max-1 ... 0
var cb_value_max = 1;			// 0: normal colors, 1: color-blind colors
var rel0_value_max = 1;			// 0: none, 1: all
var colorby_value_max = 2;		// 0: method, 1: client, 2:server
var annotateall_value_max = 1;		// 0: none, 1: all
var annotateuser_value_max = 1;		// 0: none, 1: all
var searchnot_value_max = 1;		// 0: normal, 1: invert match         
var textmultiplier_value_max = 3;	// 0: normal, 1: 0.75x, 2: 1.5x, 3: 1.25x
var basetime0_value_max = 1;		// 0: normal, 1: relative to start
var compress_value_max = 3;		// 0: none, 1: gray0.1, 2: gray0.2, 3: all

var axesmargin = 5;	// Pixels. Keep axes and pan zoom rect away from region3 edges

// Annotates: possibly cycle thru long vs. short annotations

// Note: highlighting is shift-click, because it is in the zoom/pan click area
// Behaves like shift-click to annotate

// Region 0 is HTML above the svg. see winMaergin2.top
// Region 1 is the top part of svg for title
// Region 2 is the left part of svg for Y-axis labels
// Region 3 is the middle part and holds all the timelines
// Region 4 is the not-used IPC legend
// Region 5 is two-line X-axis
// Region 6 is HTML below the SVG. see winMargin2.bottom

// Each region has a percentage of the outersvg width/height, with min and max bounds
var region1paramH = [8, 20, 80];		// Title gets 8% of height
var region5paramH = [10, 20, 80];		// X-axis and footer gets 10% of height
// Middle gets the rest ~= 82% of height

var region2paramW = [8, 50, 150];	// Y-axis gets 8% of width
var region4paramW = [5, 25, 40];	// IPC legend gets 5% of width
// Timelines get the rest ~= 90% of width


// Non-Highlighted items are displayed in gray, highlighted in color
// Heights vary by group compress value
var grayHeight = [0, 1, 5, 20];	// Subscripted by compress_xxx 
var maxTrackHeight = 20;

// 2**0.0 through 2** 0.9
var kPowerTwoTenths = [1.0000, 1.0718, 1.1487, 1.2311, 1.3195, 
                       1.4142, 1.5157, 1.6245, 1.7411, 1.8661];


//----------------------------------------------------------------------------//
// Globals about browser window and allocated SVG                             //
//----------------------------------------------------------------------------//

var winTileHeight;
var winTileWidth;
var winScale;

var winWidth = 960;	// Default 16:9, immediately overwritten
var winHeight = 540;
var svgWidth = 16;	// Default, immediately overwritten
var svgHeight = 9;

var region1height, region234height, region5height;
var region2width, region3width, region3clipwidth, region4width;

var outersvg, svgdotg, innersvg, innersvgdotg;
var region2, region2dotg;
var reddot;


//----------------------------------------------------------------------------//
// Globals for X-axis                                                         //
//----------------------------------------------------------------------------//
var axisTickPx = "16px";
var AxisLabelPx = "20px";
var titlePx = "32px";

// Scales for the axes
var x;
var x_zoomed;

// The axis definitions
var xAxis;

// The groups containing the drawn axis and vertical grid overlay
var gXgrid;
var gX;

// The svg zoom, no attach, no draw; define watcher
var myZoom_x;
var panzoomrect_x = null;


// leftmost and rightmost on-screen x values, for filtering, for speed
var realxleft;
var realxright;
var realxrightmost;	  // includes the margin.right padding
var xdomainwidth;	  // abs(right - left)
var xpixelfraction = 1.0;  // What fraction of a pixel width to do full draw
var xsecperpix = 0;	  // Only do full drawing of items >= xsecperpix
 
var xaxisfmt = {
  basetime: 0,
  deltamul: 1, 
  deltamax: 1000, 
  ovflnext: 0, 
  ovflformat: "03.0f",
  deltaformat: "03.0f"
};


//----------------------------------------------------------------------------//
// Globals for Y-axis                                                         //
//----------------------------------------------------------------------------//

// Scales for the axes
var y;
var y_zoomed;

// The axis definitions
var yAxis;

// The groups containing the drawn axis
var gY;

// The svg zoom, no attach, no draw; define watcher
var myZoom_y;
var panzoomrect_y = null;


// topmost and bottommost on-screen y values (tracks), for filtering, for speed
var realytop;
var realybottom;
var ydomainwidth;	  // abs(top - bottom)
var ypixelfraction = 1.0;  // What fraction of a pixel width to do full draw
var ypixpertrack = 0;	  // Only do full drawing of items >= ypixpertrack

// Within-track event and annotation positions and sizes, for each of
// track sizes 1..20. Function of Y-axis zoom
//  perTracksize[i].annotsize 	annotation font size in pix
//  perTracksize[i].annotcount 	annotation lines of text for this size
//                              = trunc(annotheight / annotsize)
//  perTracksize[i].eventheight pix height for drawing events
//  perTracksize[i].annotheight pix height for drawing annotation text
//  perTracksize[i].eventoffset pix offset for event centerline
//  perTracksize[i].annotoffset pix offset for annot[0] text baseline
 
var perTracksize = [];


//----------------------------------------------------------------------------//
// Globals for data and its metadata                                          //
//----------------------------------------------------------------------------//
var data = null;
var eventToRow = [];	// Map events to sorted rows. Will be 4 x 64K

// All these will be number of rows in size
var sortNum = [];		// Gives grouped event number for each row
var sortName = [];		// Gives grouped event name for each row
var rowToMinT = [];
var rowToMaxT = [];
var rowToHeight = [];		// Per row, N+1 rows
var rowToTrack = [];		// Per row, N+1 rows
var rowToHighlighted = [];	

var dataTsLo, dataTsHi, dataTsMaxDur;
var dataBaseDate, dataBaseSecond;

var sortNum_cpu_start = 0;
var sortNum_pid_start = 0;
var sortNum_rpc_start = 0;
var sortNum_res_start = 0;
var maxTrack = 0;		// Current Number of tracks

//----------------------------------------------------------------------------//
// Globals for drawing                                                        //
//----------------------------------------------------------------------------//

// These hold per-row state while drawing events
// All are subscripted by row number
var defer_dur_i = [];		// Idle
var defer_dur_u = [];		// User
var defer_dur_k = [];		// Kernel
var defer_dur = [];		// All -- nothing lost
var defer_event_u = [];		// Most recent deferred user event
var defer_event_k = [];		// Most recent deferred kernel event
var highwater_mark = [];
var rowToLabelk = [];		// Rotate event labels separately for each row
var rightmostnum = [];		// Spread apart mark_d numbers
// TODO: change to rightmostlabel and use for annots also ??
//  or separate var to deal with not too many per x-pixel

 
//----------------------------------------------------------------------------//
// Global UI state                                                            //
//----------------------------------------------------------------------------//

// Update initializeState() if you add/subtract anything here
var state = {
  filename_text: "", 
  currentcolor: normalcolor,
  cb_value: 0, 			// do not show colorblind by default
  rel0_value: 0, 		// Initially, not relative to zero
  annotateall_value: 0, 	// Off
  annotateuser_value: 0, 	// Off
  searchnot_value: 0,		// false = like grep. true = like grep -v
  search_text: "",
  usec_lo_time: 0,
  usec_hi_time: 0,
  textmultiplier_value: 0,
  basetime0_value: 0,

  // For the four groups: Cpu, Pid, Rpc, Res(ource)
  grouplength: [0, 0, 0, 0],
  groupcompress: [3, 0, 0, 0], 		// Show CPUs, collapse others
  grouplabelypos: [0, 0, 0, 0],		// In pixels, for expand/compress place 
  groupfirsttrack: [0, 0, 0, 0], 	// Label track number for expand/compress place

  // X-axis and Y-axis scaling
  savedtransformX: d3.zoomIdentity,
  savedtransformY: d3.zoomIdentity,

  // Highlighted events and their rows
  hilite_event_set: new Set(),
  hilite_row_set: new Set(),
  fullsize_row_set: new Set(),		// has at least one highlighted event

  // NOTE: save/restore does not work for sets. Sigh.
  // So instead we move sets into these arrays around save/restore
  hilite_event_array: [],
  hilite_row_array: [],
  fullsize_row_array: [],

  // List of items that are annotated on screen
  annotated_d: [],

  // Single item annotated even across pan/zoom
  annotated_one_d: -1,

  dummy_placeholder: 0		// No comma here
};



// Saving state N copies current to [N]
// Restoring state N copies current to [0] and loads current from [N]
//  (swaps cleanly if N=0)
var savedstate = [{}, {}, {}, {}, {}, {}];	// [0]..[5]
var saved_valid = [false, false, false, false, false, false];

var more_text = false;


//----------------------------------------------------------------------------//
// Other globals                                                              //
//----------------------------------------------------------------------------//

// Set the initial sizes of text
////var textsize = {tick: 24, smalltick: 18, label: 20, title: 32, annot: 12};
var textsize = {tick: 28, smalltick: 28, label: 28, title: 32, annot: 12};

// Set the initial sizes of event lines
var linewidth = {
  k4 : 28, k3 : 28, k2 : 16, k1 : 6,  
  idle : 2, u2 : 12, u1 : 8
};

// Set the initial dimensions of the graph by calling resize()
var width;
var height;
//var region234height;	// Smaller than height if not many tracks
 

// LOCAL For rubberband
var rubberband;		// Below marked object
var rubberband2;	// Above marked object
var rubberband3;	// Time between two objects
var rubberband4;	// background for rubberband3 text
var x1, y1;
var dx1, dy1;
var vx1, vx2;
var mx1, my1;
var d1, d2;		// First and second marked data objects


// LOCAL For first-seen user-mode annotation 
var dont_annotate = [];
dont_annotate[0x10000] = true;	// Never label -idle- event

// LOCAL For annotations
// 2**0.0 through 2** 0.9
var kPowerTwoTenths = [1.0000, 1.0718, 1.1487, 1.2311, 1.3195, 
                       1.4142, 1.5157, 1.6245, 1.7411, 1.8661];


// parse the date / time
var parseTime = d3.timeParse("%d-%b-%y");
 


var annotateall_toggle = false;	
var search_toggle = true;		// like grep. false = like grep -v

var dont_annotate = [];
dont_annotate[0x10000] = true;	// Never label -idle- event
// Rotate labels separately for each RPC track
var labelk = [];


//----------------------------------------------------------------------------//
// Functions                                                                  //
//----------------------------------------------------------------------------//

function strhash(s) {
  var i;
  var hash = 0;
  for (i = 0; i < s.length; ++i) {
    hash = ((hash << 3) + s.charCodeAt(i)) & 0x7FFFFFFF;
  }
//console.log("strhash:", s, " ", hash);
  return hash;
}

// return 2 * (x/10)
function exptenths(x) {
  var powertwo = Math.floor(x); 
  var fraction = Math.round(x * 10) % 10;
  var retval = 1 << powertwo;
  retval *= kPowerTwoTenths[fraction];
  return retval;
}

// return sec to transmit x bytes at y Gb/s, where 1 Gb/s = 125 MB/sec
// NO. but we assume we only get about 90% of this for real data, so 110 MB/sec
function bytestosec(x) {
  var retval = x * data.gbs / 125000000.0;
  return retval;
}

// Expecting
// [03.436344, 03.450546, 03.452781, 03.449512, "192.168.001.090", "192.168.001.055", 19.9, 0.0, 
//  3299745916, 0, "RespRcv ", "write", "Success", 10, "...data..."],

// Accessor functions for 15-element RPCs
function t1(d)  {return d[0];}
function t2(d)  {return d[1] + data.deltaT23;}
function t3(d)  {return d[2] + data.deltaT23;}
function t4(d)  {return d[3];}

function client(d)  {return d[4];}
function server(d)  {return d[5];}
function reqlglen(d)  {return d[6];}
function resplglen(d)  {return d[7];}

function rpcid(d)  {return d[8] & 0xffff;}
function parent(d)  {return d[9] & 0xffff;}
function msgtype(d)  {return d[10];}
function method(d)  {return d[11];}
function status(d)  {return d[12];}
function msglen(d)  {return d[13];}
function msgdata(d)  {return d[14];}

function t1zero(d)  {if (state.rel0_value != 0) {return t1(d) - t1(d);} else {return t1(d);}}
function t2zero(d)  {if (state.rel0_value != 0) {return t2(d) - t1(d);} else {return t2(d);}}
function t3zero(d)  {if (state.rel0_value != 0) {return t3(d) - t1(d);} else {return t3(d);}}
function t4zero(d)  {if (state.rel0_value != 0) {return t4(d) - t1(d);} else {return t4(d);}}

function t1rel(d)  {return t1(d) - basetime;}
function dur(d)  {return t4(d) - t1(d);}
function methodhash(d)  {return strhash(method(d));}
function clienthash(d)  {return strhash(client(d)) * 2;}
function serverhash(d)  {return strhash(server(d)) * 3;}

// In case some times are not filled in and thus zero, pick up largest one
function tmax(d) {return Math.max(t1(d), t2(d), t3(d), t4(d));}
function fullrpc(d) {return (0.0 < t4(d));}	// False if t4 never set


function is_idle(d) {return false;}
function is_kernel(d) {return false;}


// Split the incoming traceable string into the day part (as a string)
// and the time part (as numeric seconds). Then we can do arithmetic 
// on the seconds part to offset the base time of the X-axis.
//   "tracebase" : "2016-11-19_10:04:00"
//                  dddddddddd tttttttt
function splitTracebase() {
  dataBaseDate = data.tracebase.substr(0,10);
  dataBaseSecond = 
    (+data.tracebase.substr(11,2) * 3600) +
    (+data.tracebase.substr(14,2) * 60) +
    (+data.tracebase.substr(17,2));
//console.log(dataBaseDate, dataBaseSecond, hhmmss(dataBaseSecond + 0.123), "06.3f");
}

function getDataMetadata(data) {
  // All we want here is the range of RPC numbers 0..N-1

  rowToMaxT = new Array(sortNum.length).fill(-1);

  // Also capture initial X-axis bounds
  dataTsLo = 999;
  dataTsHi = 0;
  dataTsMaxDur = 0;
  var row;
  data.events.forEach(function(d) {
    dataTsLo =  Math.min(dataTsLo, t1(d));
    dataTsHi = Math.max(dataTsHi, t4(d));
    dataTsMaxDur = Math.max(dataTsMaxDur, t4(d) - t1(d));
  });

  // Initial X-axis bounds just after data load, before any pan/zoom
  realxleft = dataTsLo;
  realxright = dataTsHi;
  realxrightmost = dataTsHi;	  // includes the margin.right padding

console.log("rowToMinT ", rowToMinT);
console.log("rowToMaxT ", rowToMaxT);
console.log("X: ", realxleft, "..", realxright);

  // Pick off date and time
  splitTracebase();
}


// Use new data
function newdata2(data2) {
  //console.log("newdata2:", data2);
 
  // format the data
  data2.events.forEach(function(d) {
      d[0] = +d[0];	// T1
      d[1] = +d[1];	// T2
      d[2] = +d[2];	// T3
      d[3] = +d[3];	// T4
			// client
			// server
      d[6] = +d[6];	// lglen1
      d[7] = +d[7];	// lglen2
      d[8] = +d[8];	// rpcid
      d[9] = +d[9];	// parent
			// type
			// method
			// status
      d[13] = +d[13];	// datalen
  });
 
  data = data2;
  // Remove the 999.0 marker at the end
  data.events.pop();
  data2 = [];

  // Get the side arrays
  getDataMetadata(data);
};

function newdata2_resize(data2) {
  if (data2 == null) {
    data2 = dummyData;
  }
  newdata2(data2);
  resizewindow();
}
 
//creates a listener for when you press a key
//window.onkeyup = keyup;

function keyupFile(e) {
console.log("keyupFile");
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
 
  // Listens for you to press the ENTER key, at which point your web address will change to the one you have input in the file box
  if (e.keyCode == 13) {
    if (inputTextValue.substr(0,4) != "http") {
      inputTextValue = "http://127.0.0.1:8000/" + inputTextValue;
    }
    console.log("url:", inputTextValue);
    d3.json(inputTextValue, newdata2_resize);
  }
}

function keyupSearch(e) {
console.log("keyupSearch");
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
 
  // Listens for any key
  if (inputTextValue.length > 0) {
    //console.log("searchTextValue:", inputTextValue);
    annotatesearch(document.getElementById("SearchText").value, 
                   document.getElementById("SearchMin").value,
                   document.getElementById("SearchMax").value);

  } else {
    // Remove any previous lines
    resetlines();
    document.getElementById("matchcount").innerHTML = "";
  }
}
 
function keyupSearchMin(e) {
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
  state.usec_lo_time = +inputTextValue;

  // Turn off annotateall/user when search is active
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  if (IsActiveNumber(inputTextValue)) {e.target.style.backgroundColor = kActiveBackColor;}
  else                                {e.target.style.backgroundColor = kInactiveBackColor;}
 
  annotatesearch(document.getElementById("SearchText").value, 
                 document.getElementById("SearchMin").value,
                 document.getElementById("SearchMax").value);
  return;
}

function keyupSearchMax(e) {
  // Setting your input text to the global Javascript Variable for every key press
  var inputTextValue = e.target.value;
  state.usec_hi_time = +inputTextValue;

  // Turn off annotateall/user when search is active
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  if (IsActiveNumber(inputTextValue)) {e.target.style.backgroundColor = kActiveBackColor;}
  else                                {e.target.style.backgroundColor = kInactiveBackColor;}
 
  annotatesearch(document.getElementById("SearchText").value, 
                 document.getElementById("SearchMin").value,
                 document.getElementById("SearchMax").value);
  return;
}

// Watcher for mouse wheel, mouse pan within svgdotg
// When activated, changes translate/scale of view (which changes drawing), 
// resets scales x and y, reattaches to xAxis and yAxis, redraws groups gX and 
 
////var savedtransformX = {k:1, x:0, y:0};
////var savedtransformY = {k:1, x:0, y:0};
 
// Forward map pre-zoomed pixels to pan/zoom client pixels
function panzoomX(x, transform) {
  return ((x * transform.k + transform.x));
}
function panzoomY(y, transform) {
  return ((y * transform.k + transform.y));
}
 
// Forward map relative distances to relative client pixels
function zoomX(x, transform) {
  return (x * transform.k);
}
function zoomY(y, transform) {
  return (y * transform.k);
}

// Backmap mouse client pixels to pre-zoomed pixels
function panzoomInvertX(x, transform) {
  return ((x - transform.x) / transform.k);
}
function panzoomInvertY(y, transform) {
  return ((y - transform.y) / transform.k);
}
 
 
// Fancier thousands scaling, 3 digits
function shortnum(x, thousands) {
  var x0 = x;
  var k = 0;
  if (x == 0) {return d3.format(".0f")(x);}
  while (Math.abs(x0) >= thousands && k < 4) {x0 = x0 / thousands; k = k + 1;}
  while (Math.abs(x0) < 1 && k > -4) {x0 = x0 * thousands; k = k - 1;}
  // Now we have 1 <= x0 < thousands (which is expected to be 1000 or 1024),
  // if between roughly 10**-12 and 10**12
  var fmt = ".0f";
  if (x0 < 99.99) {fmt = ".1f";}
  if (x0 < 9.999) {fmt = ".2f";}
  if (x0 < 0.9999) {fmt = ".3f";}
  //fmt =".3f";  //override
  // Note space if no units scaling letter
  return d3.format(fmt)(x0) + "pnum KMGT"[k+4];
}

// Self-contained thousands scaling, 5 digits
function shortnum5(x) {
  var x0 = x;
  var k = 0;
  if (x <= 0) {return d3.format(".0f")(x);}
  while (Math.abs(x0) >= (2000) && k < 4) {x0 = x0 / 1000; k = k + 1;}
  while (Math.abs(x0) < 2 && k > -4) {x0 = x0 * 1000; k = k - 1;}
  // Now we have 2 <= x0 < 2000 
  var fmt = ".1f";
  if (x0 < 999.9) {fmt = ".2f";}
  if (x0 < 99.99) {fmt = ".3f";}
  if (x0 < 9.999) {fmt = ".4f";}
  //fmt =".3f";  //override
  // Note space if no units scaling letter
  return d3.format(fmt)(x0) + "pnum KMGT"[k+4] + "s";
}
 
// Input is a t1 in seconds for labelling an X-axis tic mark
// Uses global basetime and xaxisfmt 
// Formats the delta from basetime
function shortxtime(x) {
//console.log("shortxtime", x, xaxisfmt);
  if (xaxisfmt.deltamul == 0) {
    // Turn seconds into hh:mm
    var delta = Rnd0(x - xaxisfmt.basetime);
    var mm = Math.trunc(delta / 60);
    var ss = Math.trunc(delta) % 60;
    return (showovfl ? d3.format(xaxisfmt.ovflformat)(xaxisfmt.ovflnext) + ":" : "") + 
      d3.format("02d")(mm) + ":" + d3.format("02d")(ss);
  }
  var delta = Rnd1((x - xaxisfmt.basetime) * xaxisfmt.deltamul);
  var showovfl = (xaxisfmt.deltamax == delta);
  if (xaxisfmt.deltamax <= delta) {delta -= xaxisfmt.deltamax;}
  return (showovfl ? d3.format(xaxisfmt.ovflformat)(xaxisfmt.ovflnext) + "_" : "") + 
    d3.format(xaxisfmt.deltaformat)(delta);
}
 
function hhmmss(x) {
  var xt = Math.trunc(x);
  var milli = Math.round((x - xt) * 1000);
  var hh = Math.trunc(xt / 3600) % 60;
  var mm = Math.trunc(xt / 60) % 60;
  var ss =  Math.trunc(xt) % 60; 
//console.log("hhmmss(", x, ")=", hh, mm, ss, milli, (x - xt) * 1000);
  return d3.format("02.0f")(hh) + ":" + d3.format("02.0f")(mm) + ":" + d3.format("02.0f")(ss)  + (milli != 0 ? "." + d3.format("03.0f")(milli) : "");
}

// Reset rotating label positions per row
function resetRotatingLabelk() {
  for (var i = 0; i < maxTrack; ++i) {rowToLabelk[i] = 0;}
}

// Track for event[i] is just i 
function calculateRowTracks() {
  // Set scale domains to the range of the data
  var max_rpc = data.events.length - 1;
  // Enforce a minimum of four RPCs, for aesthetics
  max_rpc = Math.max(3, max_rpc);
  trackcount = max_rpc + 1;
  maxTrack = max_rpc;
}

// To keep the display digits manageable for the X-axis, we want to remove 
// all the common leading time and display it once as basetime.
// To do this, we first converted the incoming data.tracebase string,
//  2016-11-19_10:04:00
// to numeric seconds 0..86400
//
// Set up x zoom and call resetonscreen_x before calling this
function calculateBasetime() {
  // Current X-axis ranges from realxleft to realxright seconds from
  // dataBaseSecond
  var xaxisspan = realxright - realxleft;	// seconds
//console.log("calculateBasetime", dataBaseSecond , realxleft, realxright, xaxisspan);
 
  // We want offsets in seconds from the base seconds, no hh:mm
  var baseleft = realxleft;
  var fullbaseleft = dataBaseSecond + baseleft;
  var secfmt = "02d";

  if (60 <= xaxisspan) {
    xaxisfmt.basetime = (Math.floor(fullbaseleft / 3600) * 3600) - dataBaseSecond;	
    // Hour hh:00:00 with multiple of 10, 100, 1000 seconds shown as mm:ss
    xaxisfmt.deltamul = 0;
    xaxisfmt.deltamax = 60;
    xaxisfmt.ovflnext = Math.floor(fullbaseleft / 3600 + 1) % 60;
    xaxisfmt.ovflformat = "02d"; 
    xaxisfmt.deltaformat = "05.2f";
    document.getElementById("xaxislabel").innerHTML = "Time (mm:ss)";
  } else if (1.0 <= xaxisspan) {
    // Minute hh:mm:00
    xaxisfmt.basetime = Math.floor(fullbaseleft / 60) * 60 - dataBaseSecond;		
    xaxisfmt.deltamul = 1;
    xaxisfmt.deltamax = 60;
    xaxisfmt.ovflnext = Math.floor(fullbaseleft / 60 + 1) % 60;
    xaxisfmt.ovflformat = "02d"; 
    xaxisfmt.deltaformat = "04.1f";
    document.getElementById("xaxislabel").innerHTML = "Time (sec)";
  } else if (0.001 <= xaxisspan) {
    xaxisfmt.basetime = Math.floor(baseleft);			// Second hh:mm:ss	
    xaxisfmt.deltamul = 1000; 	
    xaxisfmt.deltamax = 1000;
    xaxisfmt.ovflnext = Math.floor(fullbaseleft + 1) % 60;
    xaxisfmt.ovflformat = "02d"; 
    xaxisfmt.deltaformat = "05.1f";
    if (0.010 <= xaxisspan) {xaxisfmt.deltaformat = "03d";}
    document.getElementById("xaxislabel").innerHTML = "Time (msec)";
  } else if (0.000001 <= xaxisspan) {
    xaxisfmt.basetime = Math.floor(baseleft * 1000) / 1000;	// Msec hh:mm:ss.mmm
    secfmt = "06.3f";
    xaxisfmt.deltamul = 1000000;
    xaxisfmt.deltamax = 1000;
    xaxisfmt.ovflnext = Math.floor(baseleft * 1000 + 1) % 1000;
    xaxisfmt.ovflformat = "03d"; 
    xaxisfmt.deltaformat = "05.1f";
    if (0.000010 <= xaxisspan) {xaxisfmt.deltaformat = "03d";}
    document.getElementById("xaxislabel").innerHTML = "Time (usec)";
  } else {
    xaxisfmt.basetime = Math.floor(baseleft * 1000000) / 1000000; // Usec hh:mm:ss.uuuuuu
    secfmt = "09.6f";
    xaxisfmt.deltamul = 1000000000;
    xaxisfmt.deltamax = 1000;
    xaxisfmt.ovflnext = Math.floor(baseleft * 1000000 + 1) % 1000;
    xaxisfmt.ovflformat = "03d"; 
    xaxisfmt.deltaformat = "05.1f"; 	
    if (0.000000010 <= xaxisspan) {xaxisfmt.deltaformat = "03d";}
    document.getElementById("xaxislabel").innerHTML = "Time (nsec)";
  }

  // If relative time, leave off the base HH:MM:SS
  if (state.rel0_value == 0) {
    document.getElementById("basetimetext").innerHTML = 
      dataBaseDate + " " + hhmmss(dataBaseSecond + xaxisfmt.basetime, secfmt);
  } else {
    document.getElementById("basetimetext").innerHTML = dataBaseDate + " 00:00:00";
  }


//console.log("basetime=", hhmmss(xaxisfmt.basetime, secfmt));
}

// Create and draw initial X-axis
function drawInitialXaxis() {
//console.log("drawInitialXaxis");

  // Define axes using scales x and y
  // This draws below Region3
  xAxis = d3.axisBottom(x)
          .ticks(10)
          .tickSize(4)
          .tickPadding(2)
          .tickFormat(shortxtime);
  xGrid = d3.axisBottom(x)
          .ticks(10)
          .tickSize(-region234height)
          .tickFormat(function() { return null; });

  // Add the x Axis group and draw the X-axis
  gX = svgdotg.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + region234height + ")")
      .call(xAxis);
  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);

  // Put the grid on top
  // This draws on top of Region3 (after drawing events)
  gXgrid = svgdotg.append("g")
    .attr("class", "axis--grid")
    .attr("transform", "translate(0," + region234height + ")")
    .call(xGrid);
  gXgrid.selectAll(".axis--grid line")  // select all the line elements for the grid
          .attr("style", "stroke-width:1px; fill:none; stroke:#F0F0F0");
  gXgrid.select(".domain").remove();	// Avoid drawing endpoint lines

  // Text label for the entire X axis is updated in calculateBasetime
}

// Create and draw initial Y-axis
// Degenerate form -- just to get the domain line
function drawInitialYaxis() {
//console.log("drawInitialYaxis");
  // This draws to the left of Region3
  yAxis = d3.axisLeft(y).ticks(0).tickSize(4);

  // Add the y Axis group
  gY = svgdotg.append("g")
      .attr("class", "axis axis--y")
      .call(yAxis);
  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);

  // Text label for the entire Y axis
  svgdotg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("class", "axis-text noselect")
      .attr("font-size", (textsize.label) + "px")
      .style("fill", "black")
      .attr("y", 0 - region2width)
      .attr("x", 0 - (region234height / 2))
      .attr("dy", "0.9em")
      .style("text-anchor", "middle")
      .text(data.axisLabelY);   
}

// Redraw the zoomed X-axis and grid
function redrawXaxis() {
  gX.call(xAxis.scale(x_zoomed));

  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);

  gXgrid.call(xGrid.scale(x_zoomed));
  gXgrid.selectAll(".axis--grid line")  // select all the new grid line elements
          .attr("style", "stroke-width:1px; fill:none; stroke:#F0F0F0");
  gXgrid.select(".domain").remove();	// Avoid drawing endpoint lines
  // Text label for the entire X axis is updated in calculateBasetime
}


// Redraw the zoomed Y-axis 
function redrawYaxis() {
//console.log("redrawYaxis");
  gY.call(yAxis.scale(y_zoomed));
  d3.selectAll(".tick")
    .attr("class", "tick noselect")
    .attr("className", "tick noselect")
    .style("font-size", axisSmallTickPx);
  // Text label for the entire Y axis is unchanged
}

function drawLabel(row, fontsize) {
  var y0 = y_zoomed(row);
  var labelypos = Rnd1(y0 + 0.4 * fontsize);

  var labelid = "labeltext";
  var labelxpos = region2width - 6;
  var labelanchor = "end";
  var labelweight = "normal";
  var labelfill = "black";
  var labeltext = row.toString();
//console.log("drawLabel", row, labelypos, labeltext);
 
  var label = region2dotg.append("text") 
      .attr("id", labelid) 
      .attr("class", "labeltext noselect")           
      .attr("transform", "translate(" + (labelxpos) + ", " +
            (labelypos) + ")")
      .attr("width", region2width)
      .attr("font-size", fontsize + "px")
      .attr("font-family", "sans-serif")
      .attr("font-weight", labelweight)
      .style("text-anchor", labelanchor)
      .style("fill", labelfill)
      .text(labeltext);

  // Tick mark
  var path = "M" + Rnd1(region2width) + "," + Rnd1(y0) + " h-4";
  region2dotg.append("path")
    .attr("class", "labeltick")
    .attr("d",  path)
    .attr("stroke-width", "1")	
    .attr("stroke", "#000000");		// black
}


// Redraw the zoomed Y-axis 
function redrawYlabels() {
//console.log("redrawYlabels");
  d3.selectAll("#labeltext").remove();
  d3.selectAll(".labeltick").remove();

  for (var row = 0; row < maxTrack + 1; ++row) {
    drawLabel(row, textsize.smalltick );
  }

}



function drawInitialPanZoom() {
  // Last, add the rectangle we anchor the zoom action to
  // If we add it earlier, we can't zoom if exactly over the line or dots
  // This draws on top of Region3 
  panzoomrect_x = svgdotg.append("rect")
    .attr("id", "panzoomrect_x")    
    .attr("x", axesmargin)       
    .attr("width", region3width - axesmargin)
    .attr("height", region234height + region5height/2)
    .attr("style", "fill:rgb(255,240,255); opacity:0");	// Transparent. 0=>0.5 to make visible

  // Define a zoom, no attach, no draw; define watcher
  // Initializes with zoomIdentity
  myZoom_x = d3.zoom()
    .filter(myFilter)
    .on("zoom", do_zoomed_x);
 
  // Apply zoom function to entire inner rectangle; sets watcher
  panzoomrect_x.call(myZoom_x);     // This just enables on the rect itself, passive


  panzoomrect_y = svgdotg.append("rect")
    .attr("x", -(0.75 * region2width))
    .attr("id", "panzoomrect_y")            
    .attr("width", 0.75 * region2width)
    .attr("height", region234height - axesmargin)
    .attr("style", "fill:rgb(255,255,240); opacity:0"); // Transparent. 0=>0.5 to make visible


  // Define a zoom, no attach, no draw; define watcher
  // Initializes with zoomIdentity
  myZoom_y = d3.zoom()
    .filter(myFilter)
    .on("zoom", do_zoomed_y);
 
  // Apply zoom function to entire inner rectangle; sets watcher
  panzoomrect_y.call(myZoom_y);     // This just enables on the rect itself, passive

}

function redrawPanZoom() {
}


// BLACK RIGHT-POINTING TRIANGLE (U+25B6)
// BLACK DOWN-POINTING TRIANGLE (U+25BC)
// Show arrow for Y-axis group name
function expandArrow(prefix) {
  return (state.groupcompress[prefix] == 0) ? "\u25B6" : "\u25BC"; 
}

 
function resetlines() {
  d3.selectAll(".verticalline").remove() ;
  d3.selectAll(".verticaldashline").remove() ;
  d3.selectAll(".markertext").remove() ;
  d3.selectAll(".rubberline").remove() ;
  d3.selectAll(".rubbertext").remove() ;
  annotateall_toggle = false;
  document.getElementById("annotateall").style.color="#808080";
  document.getElementById("annotateall").style.borderColor="#C0C0C0";
  dont_annotate = [];
  dont_annotate[0x10000] = true;	// Never label -idle- event
  // clear matches
  document.getElementById("matchcount").innerHTML = "";
}

function resetevents() {
  d3.selectAll(".graphlinex").remove();
  d3.selectAll(".graphliney").remove();
}

// Look at the displayed x-axis extent, backmapping to data values
// via x_zoomed scaler
function resetonscreen_x() {
//console.log("resetonscreen_x");
  // Initialize the left and right time values
  var xleft = x_zoomed.invert(0); 
  var xright = x_zoomed.invert(region3width); 
  var xrightmost = x_zoomed.invert(region3clipwidth);
  reset_globals_x(xleft, xright, xrightmost);
}

// Look at the displayed y-axis extent, backmapping to data values
// via y_zoomed scaler
function resetonscreen_y() {
//console.log("resetonscreen_y");
  // Initialize the top and bottom track values
  var ytop = Rnd0(y_zoomed.invert(0)); 
  var ybottom = Rnd0(y_zoomed.invert(region234height)); 
  reset_globals_y(ytop, ybottom);
}


function onscreen_x(d) {	// Allow slop
  return (t1zero(d) <= realxrightmost && realxleft <= t4zero(d));
}

function startsonscreen_x(d) {	// Allow slop
  return (t1zero(d) <= realxrightmost && realxleft <= (t1zero(d)));
}

function onscreen_y(track) {
  return (track <= realybottom && realytop <= (track));
}


// Round to zero decimal places
function Rnd0(x) {return Math.round(x);}

// Round to one decimal place
function Rnd1(x) {return Math.round(x * 10) / 10;}


// Input is a relative time, output is an absolute pixel position
function AbsPxX(tsrel) {return panzoomX(x(tsrel), state.savedtransformX);}

// Input is an rpc number, output is an absolute pixel position
function AbsPxY(rpc) {return y(rpc);}

// Input is a relative time, output is an absolute pixel position, rounded to 1/10 pixel
function AbsPxRX(tsrel) {return Rnd1(AbsPxX(tsrel));}

// Input is an rpc number, output is an absolute pixel position
function AbsPxRY(rpc) {return Rnd1(AbsPxY(rpc));}



function draw_annotateall() {
  // To reduce clutter, don't annotate the same method item repeatedly
  dont_annotate = [];
  // Rotate labels separately for each RPC track
  for (i = 0; i < trackcount; ++i) {labelk[i] = 0;}

    // Draw all lines
    for (i = 0; i < data.events.length; ++i) {
      var d = data.events[i];
      if(startsonscreen_x(d) && fullrpc(d) && (!dont_annotate[methodhash(d)])) {
        var short = true;
        var rotate = false;
        annotatespan(d, i, "first", 0, short, rotate);
        ++labelk[i];
        //dont_annotate[methodhlinewiash(d)] = true;
      }
    }
}



function drawevents() {
  // Add the lines

console.log("resetevents ====================================");
  resetevents();

  // 2021.05.22 thicker minimum for book 
  // Line width (actually height) is a function of ypixpertrack
  //var linewidth = Math.min(30, Math.max(4, ypixpertrack / 2));
  linewidth.k4 = Math.min(28, Math.max(12, ypixpertrack / 2));
//console.log("linewidth.k4", linewidth.k4, ypixpertrack);

  var notch = Math.max(3, linewidth.k4 / 2);
  var drawncount = 0;
  for (i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
//console.log("event[", i, "] ", t1(d), t4(d));
    if(!onscreen_x(d)) {continue;}
    if(!onscreen_y(i)) {continue;}
    ++drawncount;

    var startt = t1zero(d);
    var x0 = x_zoomed(startt);
    var x1 = x_zoomed(t4(d));
    var y0 = y_zoomed(i);
    var jogdown = " m0," + notch;
    var jogup = " m0,-" + notch;
    // Stroke color varies as state.colorby_value
    var strokecolor = l2color(d);

    if ((t2(d) < t1(d)) || (t4(d) < t3(d))) {
      // Time went backward -- make unaligned times visible
      jogup = " m0,5";		// go further down instead
      strokecolor = "#808080";	// medium gray
    }
//console.log("strokecolor:", strokecolor);

    var path = "M" +  Rnd1(x0) + "," + Rnd1(y0) + 
               " h" + Rnd1(x_zoomed(t2(d)) - x_zoomed(t1(d))) +
               jogdown + 
               " h" + Rnd1(x_zoomed(t3(d)) - x_zoomed(t2(d))) +
               jogup +
               " h" + Rnd1(x_zoomed(t4(d)) - x_zoomed(t3(d)));

    var txtmul = textmultiplier_tbl[state.textmultiplier_value];

    innersvgdotg.append("path")
       .attr("class", "graphlinex")
       .attr("d",  path)
       .attr("fill", "none")
       .attr("stroke-width", linewidth.k4)
       ////.attr("stroke-width", 6 * txtmul)
       .attr("stroke", strokecolor);	// varies by method 

    // Draw approximate transmission time on the wire
    var reqsec = bytestosec(exptenths(reqlglen(d)) + 100);	// ~100B overhead per msg
    var respsec = bytestosec(exptenths(resplglen(d)) + 100);	
    var halfreq = (t2(d) - t1(d) - reqsec) * 0.5;		// center in req time
    if (halfreq < minslop_sec) {
      //reqsec -= Math.max(0, 2 * minslop_sec);
      //halfreq = minslop_sec;
    }
    var halfresp = (t4(d) - t3(d) - respsec) * 0.5;		// center in req time
    if (halfresp < minslop_sec) {
      //respsec -= Math.max(0, 2 * minslop_sec);
      //halfresp = minslop_sec;
    }

    var skiptoreq = halfreq;
    var skiptoresp = halfreq + (t3(d) - t2(d)) + halfresp;

    var path2 = "M" +  Rnd1(x0) + "," + Rnd1(y0) + 
                  " m" + Rnd1(x_zoomed(skiptoreq)- x_zoomed(0)) + ",0" +
                  " h" + Rnd1(x_zoomed(reqsec)- x_zoomed(0)) +
                  " m" + Rnd1(x_zoomed(skiptoresp)- x_zoomed(0)) + ",0" +
                  " h" + Rnd1(x_zoomed(respsec)- x_zoomed(0));
    innersvgdotg.append("path")
       .attr("class", "graphliney")
       .attr("d",  path2)
       .attr("fill", "none")
       .attr("stroke-width", linewidth.k4 / 3)	// rls 2021.05.25 bigger for book
       ////.attr("stroke-width", 2)
       .attr("stroke", "#FFFFFF");	// white

  }
console.log(drawncount, "events drawn");
}

// Just look at start time of each item in annotated_d
function FindNearestAnnotated(t) {  
  var nearest = -1;
  var nearestdist = 0;
  // Ignore y for a match, ignore duration  
//console.log("annotated_d.length=", state.annotated_d.length);
  for (j = 0; j < state.annotated_d.length; ++j) {
    var i = state.annotated_d[j];
    var d = data.events[i];
    if (!fullrpc(d)) {continue;}
    var dist = Math.abs(t1(d) - t);
//console.log("  ", i, t1(d), t, dist); 
    if ((nearest < 0) || (dist < nearestdist)) {
      nearest = i;
      nearestdist = dist;
    }
  }
//console.log("  =", nearest); 
  return nearest;
}


// BUG: strictly speaking, the left/right top/bottom should map just the
//   +/-5 pixel domain, not full region3width/region234height.
//   But the scaling below is correct, since both range and domain are large by 5px

// Width across the diagram is region3width pixels
// Width across the diagram is xdomainwidth seconds
// One pixel is xdomainwidth / width seconds
function reset_globals_x(xleft, xright, xrightmost) {
//console.log("reset_globals_x", xleft, xright);
  realxleft = xleft;
  realxright = xright;
  realxrightmost = xrightmost;
  xdomainwidth = Math.abs(xright - xleft);
  xsecperpix = (xdomainwidth / region3width) * xpixelfraction;
//console.log("NSEC per pixel", Math.round(xsecperpix * 1000000000.0));
}

// Height across the diagram is region234height pixels
// Height across the diagram is ydomainwidth tracks
// One track is region234height / ydomainwidth pixels
//   Note: this is the inverse of the ratio used for X-axis time above
function reset_globals_y(ytop, ybottom) {
console.log("reset_globals_y", ytop, ybottom);
  realytop = ytop;
  realybottom = ybottom;
  ydomainwidth = Math.abs(ytop - ybottom);
  ypixpertrack = (region234height / ydomainwidth) * ypixelfraction;
  calcPixHeightsPerTrack(ypixpertrack);
}


// Because of auto-pruning of Y-axis rows that cannot possibly overlap the X span
// on screen, updating X will in general require also updating the Y-axis
function do_zoomed_x() { 
//console.log("do_zoomed_x ----------", d3.event.transform.k);
  // Pick up  the new transform and apply it
  state.savedtransformX = d3.event.transform;
  state.savedtransformX.y = 0;	// Scrolling X does not change Y
	
  // Renumber the track heights per row, to auto-prune rows no longer visible
  // Use x_zoomed when drawing everything after this  
  // Set up x_zoomed, y_zoomed and Recalculate X- and Y- on-screen limits
  resetRangeDomain();

  calcPixHeightsPerTrack(ypixpertrack);

  // Remember nearest annotated event to the mouse click, to display after pan
  var m = d3.mouse(this);
  var mx = m[0];
  var my = m[1];
  var t = x_zoomed.invert(mx);
  var y_track = y_zoomed.invert(my);
  if (0 <= y_track) {
    state.annotated_one_d = FindNearestAnnotated(t);
  }

  // Turn off annotateall/user after pan/zoom
  state.annotateall_value = 0;
  state.annotateuser_value = 0;


  // Nothing below this depends on d3.event
  // ---------------------------------------
  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  // Redraw the zoomed X-axis and grid
  redrawXaxis();

  // Redraw the pruned Y-axis
  ////redrawYaxis();
  redrawYlabels();

//console.log("end do_zoomed_x ----------");
}


// Tracks contain event lines and annotation text, split in some proportion
// The pixel height for a trackheight is ypixpertrack * t_height
// The font-size for annotation text has a minimum and grows slowly, allowing
// room for 0..4+ lines depending on zoom. It is 8 + (xx - 8) / 6
// Event offset is forced to be an integer number of pixels, to allow
//  subscripting by Y-position
// NO. give up on offsets being exact integers. use rnd1
//
function calcPixHeightsPerTrack(pixpertrack) {
//console.log("calcPixHeightsPerTrack", pixpertrack);
  // Calculate sizes and offsets per track height 1..10
  var minannot = Math.min(28, Math.max(12, 0.75 * textsize.smalltick));
  for (var i = 0; i <= maxTrackHeight; ++i) {
    perTracksize[i] = {};
    var trackheight = i * pixpertrack;
    var annotfontsize = minannot;
    var e_height;
    if (minannot < trackheight) {
      // Grow slowly
      annotfontsize += Rnd0((trackheight - minannot) / 20);
    }
    perTracksize[i].annotsize = annotfontsize;

    if ((annotfontsize * 2) <= trackheight) {
      // Normal case, allocate half the track height to events, half to annots
      e_height = Rnd1(trackheight / 2);
      perTracksize[i].eventheight = e_height;
      perTracksize[i].annotheight = trackheight - e_height;
      perTracksize[i].eventoffset = Rnd1(e_height / 2);		// Centered in top half
      perTracksize[i].annotoffset = Rnd1(trackheight / 2 + annotfontsize);
    } else if (annotfontsize <= trackheight) {
      // No room for annotations; hold event line height steady
      e_height = Rnd1(annotfontsize);
      perTracksize[i].eventheight = Rnd1(annotfontsize);
      perTracksize[i].annotheight = 0;
      perTracksize[i].eventoffset = Rnd1(e_height / 2);	// Centered near top
      perTracksize[i].annotoffset = Rnd1(trackheight + annotfontsize * 0.67);  
    } else {
      // No room for annotations and need to shrink event height
      e_height = Rnd1(trackheight);
      perTracksize[i].eventheight = e_height;
      perTracksize[i].annotheight = 0;
      perTracksize[i].eventoffset = Rnd1(e_height / 2);	// Centered near top
      perTracksize[i].annotoffset = Rnd1(trackheight + annotfontsize * 0.67);  
    } 
    perTracksize[i].annotcount = 
      Math.max(1, Math.trunc(perTracksize[i].annotheight / annotfontsize));
  }

//console.log("perTracksize", perTracksize);
}

function do_zoomed_y() { 
//console.log("do_zoomed_y ----------", d3.event.transform.k);
  // Pick up  the new transform and apply it
  state.savedtransformY = d3.event.transform;
  state.savedtransformY.x = 0;	// Scrolling Y does not change X

  // Set up offsets and line widths per track heights [1..10] 
	
  // Renumber the track heights per row, to auto-prune rows no longer visible
  y.domain([0, maxTrack + 1]);
  resetRangeDomain();

  calcPixHeightsPerTrack(ypixpertrack);

  // Nothing below this depends on d3.event
  // ---------------------------------------

  // Turn off annotateall/user after pan/zoom
  state.annotateall_value = 0;
  state.annotateuser_value = 0;

  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  // Redraw the zoomed Y-axis
  redrawYlabels();

//console.log("end do_zoomed_y ----------");
}
 

// Reset zoom to original full trace
// Reset a few data-related pieces of state
// Save to state[0] just before resetting, in case reset is a mistake
function resetzoom() {
//console.log("resetzoom ==================");
  allocOuterSvgEtc();
}


// Annotate all items on screen. Use sparingly at deep zoom only...
// Toggles on and off 
function annotateall() {
  var old_toggle = annotateall_toggle;
  // Remove any previous lines. Note: this resets annotateall_toggle too
  resetlines();
  if (old_toggle) {
    // Turn off previous annotate and exit
    annotateall_toggle = false;
    document.getElementById("annotateall").style.color="#808080";
    document.getElementById("annotateall").style.borderColor="#C0C0C0";
  } else {
    draw_annotateall();
    annotateall_toggle = true;
    document.getElementById("annotateall").style.color="#000080";
    document.getElementById("annotateall").style.borderColor="#0000FF";
  }
}
 
// Annotate all items on whose name contains search string. 
function annotatesearch(needle, mindur, maxdur) {
  // Remove any previous lines
  resetlines();
  document.getElementById("matchcount").innerHTML = "";

  var units_divisor = 1000000.0;
  var mindurval = +mindur / units_divisor;	// Minimum duration converted to seconds
  var maxdurval = +maxdur / units_divisor;	// Maximum duration converted to seconds
  if (maxdurval == 0) {maxdurval = 999.9;}	// Turn empty box into ~17 minutes max

  // Ignore 1-char searches with zero durations -- too many matches
  if (!IsActiveText(needle) && !IsActiveNumber(mindurval) && !IsActiveNumber(maxdurval)) {return;} 

  // Rotate labels separately for each RPC track
  for (i = 0; i < trackcount; ++i) {labelk[i] = 0;}

  // Draw all matching lines
  var matchcount = 0;	// number of matches
  var durcount = 0;	// total duration of matches
  for (i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    // Invert search match if search_toggle = false
    var hit = (fullname(d, false).search(needle) >= 0);
    hit |= (client(d).search(needle) >= 0);
    hit |= (server(d).search(needle) >= 0);
    hit |= (msgdata(d).search(needle) >= 0);
    hit &= (mindurval <= dur(d));
    hit &= (dur(d) <= maxdurval);

    if(startsonscreen_x(d) && fullrpc(d) && (hit == search_toggle)) {
      var short = true;
      var rotate = false;
      annotatespan(d, i, "first", 0, short, rotate);
      ++labelk[i];
      ++matchcount;
      durcount += dur(d);
    }
  }
  document.getElementById("matchcount").innerHTML = matchcount + ", " + shortnum5(durcount);
}
 
// Toggle the search/not state
// setting search_toggle = true, display gray ! in gray outline box
// setting search_toggle = false, display blue ! in blue outline box (active)
function searchnot() {
  // Remove any previous searches
  resetlines();
  if (!search_toggle) {
    search_toggle = true;	// like grep -v
    //document.getElementById("searchnot").style.backgroundColor="#EEE0FF";
    document.getElementById("searchnot").style.color="#808080";
    document.getElementById("searchnot").style.borderColor="#C0C0C0";
  } else {
    search_toggle = false;	// normal matches
    document.getElementById("searchnot").style.color="#000080";
    document.getElementById("searchnot").style.borderColor="#0000FF";
  }
  //console.log("search = '", document.getElementById("SearchText").value, "'");
  ////annotatesearch(document.getElementById("SearchText").value);
  annotatesearch(document.getElementById("SearchText").value, 
                 document.getElementById("SearchMin").value,
                 document.getElementById("SearchMax").value);
}


 
// on mousedown -- start line at backmap of pos clientX clientY button=0 and shiftKey=true , remove any prior visible line
//  create mousemove mouseup listener
// mousemove -- continue line, redraw  clientX clientY
// moutseup -- abandon line if shiftKey=true
//                   keep line visible if shiftKey=false
// mouseout mouseleave -- ignore until mousein
// mouseenter mouseover
// event.stopPropagation()
 
 
// To snap to nearest point, we have mouse point x,y scaled to data units and data array.
// Taking advantage of data being sorted by x value, we use bisect (binary search) to find a nearby point
// Then refine based on two nearby points to see closest x** + y**2. 
// THIS: Or not bother and just use closest x. Snap x1y1 or x2y2 to that point.
// Consider not snapping if too far away.
 
// For convenience, we want to binary search in raw client pixels.
// So in function(d) we map data into range/domain and then into pan/zoom
 
var bisectPoint = d3.bisector(function(d) { return panzoomX(x(t1(d)), state.savedtransformX); }).left;
 
// Snap raw input [x,y] pair to nearest x in data, returning [x',y'] of that data point
function doSnap(xy, data) {
    var i = bisectPoint(data.events, xy[0], 1, data.events.length - 1);
//console.log("doSnap i =", i, data.events[i]);
    var xa = panzoomX(x(t1(data.events[i - 1])), state.savedtransformX),
        ya = panzoomY(y(data.events[i - 1][2]), state.savedtransformY),
        xb = panzoomX(x(t1(data.events[i])), state.savedtransformX),
        yb = panzoomY(y(data.events[i][2]), state.savedtransformY);
//console.log("doSnap mouse =", xy[0], xy[1], "events = ", xa, ya, xb, yb);
    if (xy[0] - xa < xb - xy[0]) {return [xa, ya, i];}
    return [xb, yb, i];  
}

// Snap raw input [x,y] pair to nearest x in data, returning [x',y'] of that data point
// x is in the time domain, and y is an RPC track number. Just return the nearest track
function FindNearestEvent(x, y) {
  var nearest = -1;
  var nearestdist = 0;
  // Round y to an integer and require that for a match
  var inty = Math.min(trackcount - 1, Math.max(0, Math.round(y)));
  return inty;
  
// Below part is defunct
console.log("FindNearest:", x, y, inty, data.events.length); 
  for (i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
//console.log("dist, d:", i, d); 
    if (i == inty) {
      var dist;
      var left = t1(d);
      var right = t4(d);
      if (x < left) { dist = left - x;}
      else if (right < x) {dist = x - right;}
      else {dist = 0;}
//console.log("dist, d:", dist, i, d); 
      if ((nearest < 0) || (dist < nearestdist)) {
        nearest = i;
        nearestdist = dist;
      }
    }
  }
  if (nearest == -1) {nearest = 0;}
  return nearest;
}

// Create full event name
function fullname(d, short) {
  var fulltext;
  if (short) {
    // Short form is name truncated to 8 chars, plus any (non-zero) arg
    fulltext = method(d) + "." + rpcid(d).toString();
  } else {
    // Long form is full name, plus any (non-zero) arg and retval
    fulltext = method(d) + "." + rpcid(d).toString();
  }
  return fulltext;
}
 
function CalcOffset(d, i) {
  return (1 + (labelk[i] % 3)) * 0.8;
}

// Mark a time span with vertical line and text time/name/duration 
function annotatespanvxvy(vx, vy, d, i, clss, offsety, short, rotate) {
    rubberband = innersvgdotg.append("path")	// Placeholder objects
        .attr("class", "verticalline " + clss);
    rubberband2 = innersvgdotg.append("path")	// Placeholder objects
        .attr("class", "verticaldashline " + clss);
    rubbertextx = innersvgdotg.append("text")
        .attr("class", "markertext " + clss);

    // Create text string
    var fulltext = fullname(d, short);
    if (!short) {
      // Long form includes start time and duration
      var timetxt = shortnum5(t1(d));
      fulltext = timetxt + " " + fulltext + "; " + shortnum(dur(d), data.thousandsX) + data.shortUnitsX;
    } 

    // Show the string
//console.log("vx,vy ", vx, vy);
    rubbertextx
      .attr("transform", "translate(" + (vx + 4) + "," + (vy + linewidth.k4 * 0.55) + ")scale(1,1)")
      .attr("dy", (offsety + 1) * linewidth.k4)
      .attr("font-size", linewidth.k4 + "px")
      .text(fulltext);

    // Drop a vertical line down to diagramheight at item start
    var path = d3.path();
    path.moveTo(vx, vy + linewidth.k4 * 0.55);
    path.lineTo(vx, region234height);

    // Update the path placeholder
    rubberband.attr("d", path);

    // Pop a vertical dashed line up to 4 (a little space under title) at item start
    var path2 = d3.path();
    path2.moveTo(vx, 4);
    path2.lineTo(vx, vy - linewidth.k4 * 0.50);

    // Update the path placeholder
    rubberband2.attr("d", path2);
 
    return vx;
}

function annotatespan(d, i, clss, offsety, short, rotate) {
    var vx = x_zoomed(t1zero(d));
    var vy = y_zoomed(i);
    return annotatespanvxvy(vx, vy, d, i, clss, offsety, short, rotate);
}

 
// If mouse is in Region2, go affect Y, else we are in Region3 and affecting X
// But if at far left 1/4 of region2, ignore here (shift-click label rotates compress) 
function inHilitePartOfRegion2(x) {
  if (0 <= x) {return false;}
  if (x < (-0.75 * region2width)) {return false;}
  return true;
}

// m has mouse pixel coordinates [x,y]
function mousedown_y(m) {
//console.log("mousedown_y");
  // If not shiftKey, pass it on
  if (!d3.event.shiftKey) {
    return;
  }
  d3.event.stopPropagation();

  // Backmap and turn on highlights here
  var hilite_row = doSnap_y(m[1]);
//console.log("  hilite_row", hilite_row, sortName[hilite_row]);
  state.hilite_row_set.add(hilite_row);

  // scan events array and for all onscreen and in this row, add those 
  // events to hilite_event_set and *each* of their rows to hilite_row_set
  for (var i = 0; i < data.events.length; ++i) {
    var d = data.events[i];
    ffHiliteEvent(d, i, hilite_row);
  }
//console.log("hilite_event_set", state.hilite_event_set);
//console.log("hilite_row_set", state.hilite_row_set);

  y.domain([0, maxTrack + 1]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  redrawEventsEtc();
  redrawYlabels();

}
 
// m has mouse pixel coordinates;
function mouseup_y(m) {
//console.log("mouseup_y");
  // If shift key is still down, remove all highlights
  if (d3.event.shiftKey) {
    state.hilite_event_set.clear();
    state.hilite_row_set.clear();
    state.fullsize_row_set.clear();
//console.log("hilite erased");
  }
  d3.event.stopPropagation();

  y.domain([0, maxTrack + 1]);
  resetRangeDomain();
  calcPixHeightsPerTrack(ypixpertrack);

  redrawEventsEtc();
  redrawYlabels();

}

// Return closest notch time to dx
function bestnotch(d, dx) {
  var tt = t1(d);   var diff = Math.abs(t1(d) - dx);
  if (diff > Math.abs(t2(d) - dx)) {tt = t2(d); diff = Math.abs(t2(d) - dx);} 
  if (diff > Math.abs(t3(d) - dx)) {tt = t3(d); diff = Math.abs(t3(d) - dx);} 
  if (diff > Math.abs(t4(d) - dx)) {tt = t4(d); diff = Math.abs(t4(d) - dx);} 
  return tt;
}


// Mouse clicks on main SVG area come here. Those with 0 <= x affect Region3 and
// those with x < 0 affect Region2
function mousedown_x() {
console.log("mousedown_x");
    // If not shiftKey, pass it on
    if (!d3.event.shiftKey) {
      return;
    }
    d3.event.stopPropagation();

    // Accumulate rubberlines as long as shift-click
    //resetlines();
  
    var m = d3.mouse(this);
    mx1 = m[0];		// Remember so we can check for tiny movement in mousemove_x
    my1 = m[1];		// Remember so we can check for tiny movement in mousemove_x
//console.log("mousedown at", mx1, my1);
    if (inHilitePartOfRegion2(mx1)) {mousedown_y(m); return;}

    dx1 = x_zoomed.invert(mx1);	// time
    dy1 = y_zoomed.invert(my1);	// track
//console.log("mousedown_x at", dx1, dy1, "realxleft", realxleft);

    // Find nearest data object
    var i = FindNearestEvent(dx1, dy1); 
    if (i < 0) {return;}

//console.log("nearest", i);
    d1 = data.events[i];
    if (!fullrpc(d1)) {return;}

    // Draw and label vertical line at start or end of object
    var short = false;
    var rotate = true;

    // Forward map data item start or end, snapping to closest end
    dx1 = bestnotch(d1, dx1);		// Keep for mousemove_x also
    var vx = x_zoomed(dx1);
    var vy = y_zoomed(i);
    if (state.rel0_value != 0) {vx -= x_zoomed(t1(d1));}
    vx1 = annotatespanvxvy(vx, vy, d1, i, "first", 0, short, rotate);

    // Always keep around the most recent explicit click
    state.annotated_d.push(i);
    state.annotated_one_d = i;
//console.log("mousedown_x annotated_one_d=", state.annotated_one_d); 
   
    // Set up for possible drag
    svgdotg.on("mousemove", mousemove_x);
}
 
// Rubber band shift-click-drag to see timespan
function mousemove_x() {
//console.log("mousemove_x");
    d3.event.stopPropagation();

    var m = d3.mouse(this);
    var mx2 = m[0];
    var my2 = m[1];

    var deltamx = Math.abs(mx1 - mx2);
    var deltamy = Math.abs(my1 - my2);
    if ((deltamx < 5) && (deltamy < 5)) {return;}	// Move at least 5 px
  
    // Remove any previous second line
    d3.selectAll(".second").remove();

    rubberband3 = innersvgdotg.append("path")	// Placeholder objects
        .attr("class", "rubberline second");

    // backmap mouse client pixels to pre-zoomed pixels
    var dx2 = x_zoomed.invert(mx2);	// time
    var dy2 = y_zoomed.invert(my2);	// track
//console.log("mousemove at", dx2, dy2);

    // Find nearest data object
    var i = FindNearestEvent(dx2, dy2); 
    if (i < 0) {return;}

    d2 = data.events[i];
    if (!fullrpc(d2)) {return;}
    // Draw and label vertical line at start or end of object
    var short = false;
    var rotate = false;

    // Forward map data item start or end, snapping to closest end
    dx2 = bestnotch(d2, dx2);
    var vx = x_zoomed(dx2);
    var vy = y_zoomed(i);
    if (state.rel0_value != 0) {vx -= x_zoomed(t1(d2));}
    vx2 = annotatespanvxvy(vx, vy, d2, i, "second", 1, short, rotate);

    // Always keep around the most recent explicit click
    if (state.annotated_d.length < 2) {
      state.annotated_d.push(i);
    } else {
      state.annotated_d[state.annotated_d.length - 1] = i;	// Don't keep pushing
    }

    state.annotated_one_d = i;
  
    // Make a path at the bottom and label it
    var path = d3.path();
    path.moveTo(vx1, region234height - 4);
    path.lineTo(vx2, region234height - 4);
    // Update the path placeholder
    rubberband3.attr("d", path);

    var deltax = Math.abs(dx1 - dx2) * data.shortMulX;
    var deltatext = shortnum5(deltax);

    // Put something behind the delta so it is visible even if on top of timelines
    var xmid = Rnd1((vx1 + vx2) / 2);
    var ymid = Rnd1(region234height - 8);
    var textwidth = Rnd1((deltatext.length + 2) * textsize.smalltick * 0.5);

    innersvgdotg.append("rect")
      .attr("class", "rubberbackground second")    
      .attr("x", (xmid - textwidth / 2) + "px")       
      .attr("y", (ymid - textsize.smalltick * 0.9) + "px")       
      .attr("width", textwidth + "px")
      ////.attr("height", axisSmallTickPx)
      .attr("height", linewidth.k4 + "px")
      .attr("style", "fill:rgb(255,255,255); opacity:0.875"); 

    // Label the line
    rubbertextx = innersvgdotg.append("text")
        .attr("class", "markertext noselect second");
    rubbertextx
      .attr("transform", 
            "translate(" + (xmid) + "," + 
             (ymid) + ")scale(1,1)")
      .attr("font-size", linewidth.k4 + "px")
      .style("text-anchor", "middle")
      .text(deltatext);   
}
 
// Mouse clicks on main SVG area come here. Those with 0 <= x affect Region3 and
// those with x < 0 affect Region2
function mouseup_x() {
//console.log("mouseup_x");
    d3.event.stopPropagation();
    var m = d3.mouse(this);
    var mx = m[0];
    var my = m[1];
//console.log("mouseup_x at", mx, my);
    // If mouse is in Region2, go affect Y, else we are in Region3 and affecting X
    if (inHilitePartOfRegion2(mx)) {
      mouseup_y(m); 
      return;
    }

    svgdotg.on("mousemove", null);	// Stop drag
    // If shift key is still down, remove all rubberlines and clear annots
    if (d3.event.shiftKey) {
      resetlines();
      state.annotated_d = [];
      state.annotated_one_d = -1;
    }
}



 
 
 
 
// Our window size changed out from underneath us
function resizewindow() {
  console.log("resizewindow");
  allocOuterSvgEtc();

  ////// winWidth = window.innerWidth || e.target.outerWidth;
  ////// winHeight = window.innerHeight || e.target.outerHeight;
  ////winWidth = window.innerWidth;
  ////winHeight = window.innerHeight;
  ////resize2(); BOGUS
  ////resetzoom();
}
 
 

 
function myFilter() {
  return !d3.event.shiftKey;
}
 
// HSB(n mod 15, 1, 1) These are the ones actually used
// darker lime-greens for book
var color15 = [
  // "#FF0000", "#FF6600", "#FFCC00", "#CCFF00", "#66FF00", 
  "#FF0000", "#FF6600", "#FFCC00", "#CCE000", "#66E000", 
  "#00FF00", "#00FF66", "#00FFCC", "#00CCFF", "#0066FF", 
  "#0000FF", "#6600FF", "#CC00FF", "#FF00CC", "#FF0066", 
];

// HSB(n mod 17, 1.0, 0.8)
var color17 = [
  "#CC0000", "#CC4700", "#CC8F00", "#BECC00", "#77CC00", 
  "#30CC00", "#00CC18", "#00CC5F", "#00CCA7", "#00A7CC", 
  "#005FCC", "#0018CC", "#3000CC", "#7700CC", "#BE00CC", 
  "#CC008F", "#CC0047", 
];

// unknown: light yellow, trap: light red, interrupt: light blue, syscall: light green
var kernelcolor = [
  "#FFFFE0", "#FFFFE0", "#FFFFE0", "#FFFFE0", 
  "#FFC0C0", "#C0C0FF", "#FFC0C0", "#C0C0FF",  
  "#E0FFE0", "#E0FFE0", "#E0FFE0", "#E0FFE0", 
  "#E0FFE0", "#E0FFE0", "#E0FFE0", "#E0FFE0", 
  ];





// Return outermost outline, grey for kernel, white otherwise
function l4color(d) {
  if (is_kernel(d)) {return "#808080";}
  return"#FFFFFF";
}
function l3color(d) {
  if (is_kernel(d)) {return kernelcolor[methodhash(d) >> 8];}
  return"#FFFFFF";
}
// The multiplies keep the colors for n and n+1 somewhat uncorrelated
// The plus keeps the colors for 0 somewhat apart
function l2color(d) {
  if (is_idle(d)) {return "#FFFFFF";}
  if(state.colorby_value == 0) {return color15[methodhash(d) % 15];}
  if(state.colorby_value == 1) {return color15[clienthash(d) % 15];}
  if(state.colorby_value == 2) {return color15[serverhash(d) % 15];}
  return"#FF8080";
}
function l1color(d) {
  if (is_idle(d)) {return "#000000";}
  return color17[(methodhash(d) * 5 + 6) % 17];
}


function l4width(d) {
  if (is_kernel(d)) {return linewidth.k4;}
  return 0;
}
function l3width(d) {
  if (is_kernel(d)) {return linewidth.k3;}
  return 0;
}
function l2width(d) {
  if (is_idle(d)) {return 0;}
  if (is_kernel(d)) {return linewidth.k2;}
  return linewidth.u2;
}
function l1width(d) {
  if (is_idle(d)) {return linewidth.idle;}
  if (is_kernel(d)) {return linewidth.k1;}
  return linewidth.u1;
}

var datasize;

// NOP. failed experiment
function mid90percent(d, i) {
  return true;
  //return (datasize < 1000) || ((datasize * 0.05) <= i && i <= (datasize * 0.95));
} 
 

// Set up the initial scaling for X-axis and Y-axis
function setInitialRangeDomain() {
console.log("setInitialRangeDomain", dataTsLo, dataTsHi, 0, maxTrack); 
  // Set the scales and ranges
  // Initialize the left and right values
  state.savedtransformX = d3.zoomIdentity;
  state.savedtransformY = d3.zoomIdentity;

//console.log("***** initial state.savedtransformY", state.savedtransformY);

  // To keep circles all visible within the svg clipping rectangle, 
  // we need ~5px of padding around the range
  x = d3.scaleLinear()
      .range([axesmargin, region3width - axesmargin])
      .nice(10);
  x.domain([dataTsLo, dataTsHi]);

  // Zoomed version of x scale above
  x_zoomed = state.savedtransformX.rescaleX(x);

  // Initial X-axis bounds just after data load, before any pan/zoom
  reset_globals_x(dataTsLo, dataTsHi, dataTsHi);

  y = d3.scaleLinear()
      .range([axesmargin, region234height - axesmargin])
      .nice(maxTrack + 1);
  y.domain([0, maxTrack + 1]);	// N tracks

  // Zoomed version of x scale above
  y_zoomed = state.savedtransformY.rescaleY(y);

  // Initial Y-axis bounds just after data load, before any pan/zoom
  reset_globals_y(0, maxTrack + 1);
}


// Set up the scaling for X-axis and Y-axis after zoom/pan of either
function resetRangeDomain() {
//console.log("resetRangeDomain");

  // Zoomed version of x scale above
  x_zoomed = state.savedtransformX.rescaleX(x);

//console.log("resetRangeDomain state.savedtransformX", state.savedtransformX);


  // New X-axis bounds
  resetonscreen_x();

  // Zoomed version of x scale above
  y_zoomed = state.savedtransformY.rescaleY(y);

//console.log("y_zoomed.domain", y_zoomed.domain());
//console.log("y_zoomed.range", y_zoomed.range());


  // New Y-axis bounds 
  resetonscreen_y();
}



 
 
//function keyup(e) {
//console.log("keyup", e);
//  if (e.target.input == document.getElementById("SearchText")) {keyupSearch(e);}
//  else {keyupFile(e);}
//}



// Want at least two characters for active searchng
function IsActiveText(t) {
  return t.length >= 1;
}

// Want more than one digit for active searchng
function IsActiveNumber(n) {
  return +n >= 1;
}

 
// Flip reddot to cyan if color-blind is set
function decorateDot(elem, val) {
 if (val) {
    elem.style="fill: rgb(0,255,255);";
  } else {
    elem.style="fill: rgb(255,0,0);";
  }
}

function resetText(elem, val) {
  elem.value = val;
  if (IsActiveText(val)) {elem.style.backgroundColor= kActiveBackColor;}
  else                   {elem.style.backgroundColor= kInactiveBackColor;}
}

function resetNum(elem, num) {
  if (num == 0) {
    elem.value = "";
    elem.style.backgroundColor = kInactiveBackColor;
  } else {
    elem.value = num;
    elem.style.backgroundColor = kActiveBackColor;
  }
}

// Fill in UI text and buttons entirely from current state
// Must be called after fillOuterSvg establishes save0text, etc.
function redrawUI() {
  resetText(document.getElementById("FileName"), state.filename_text);
  resetText(document.getElementById("SearchText"), state.search_text);
  resetNum(document.getElementById("SearchMin"), state.usec_lo_time);
  resetNum(document.getElementById("SearchMax"), state.usec_hi_time);
  ////resetText(document.getElementById("SearchMin"), state.usec_lo_text);
  ////resetText(document.getElementById("SearchMax"), state.usec_hi_text);

  // TEMP commented out to let my debug info show through
  // document.getElementById("matchcount").innerHTML = "";

  decorateButton(document.getElementById("relzero"), state.rel0_value);
  decorateButton(document.getElementById("colorby"), state.colorby_value);
  document.getElementById("colorby").style.width = '65px';
  decorateButton(document.getElementById("annotateall"), state.annotateall_value);
  decorateButton(document.getElementById("searchnot"), state.searchnot_value);
  decorateDot(document.getElementById("reddot"), state.cb_value);
}

function redrawEvents() {
  //console.log("redrawEvents");

  // Draw all the rectangles
  drawevents();
}


// Called when starting all over with new window size
// Outer and inner SVGs exist but are empty
//
// Order of drawing:
//  +Set x and y domain & range
//  Calculate row height and tracks
//  Calculate basetime
//
//  Draw all the events in region3
//
//  Draw Y-axis in region2
//  Draw X-axis in region5
//  Draw grid in region3
//
//  Draw scroll in region3
//  Draw scroll in region2
//
// Remove and reset annotations, calc X and Y scaling, draw events
// Set up x zoom and call resetonscreen_x before calling this
// Do this before drawing axes, which depend on calculateBasetime
function redrawEventsEtc() {
  console.log("redrawEventsEtc", data.events.length, "events");

  resetlines();
  resetRotatingLabelk();

  // Calculate per-row track height and position
  calculateRowTracks();

  // Calculate and display basetime
  calculateBasetime();

  // Draw all events onscreen
  redrawEvents();

  // If there is a previous single annotation and it is onscreen, draw it
  if (state.annotated_one_d != -1) {
    // Put just it into annotated list so that further pan/zoom finds it
    state.annotated_d = [];
    state.annotated_d.push(state.annotated_one_d);  // Keep
    var d = data.events[state.annotated_one_d];
    if (startsonscreen_x(d)) {
      var short = false;
      var rotate = false;
      annotatespan(d, state.annotated_one_d, "first", 0, short, rotate)
    }
  }
};

// If shift-click, cycle 0, max, max-1, ...
// If plain click, toggle between 0 and max
function doToggle(shifted, val, max) {
  var newval;
  if (shifted) {
    if (val == 0) {newval = max;} else {newval = val - 1;}
  } else {
    if (val == 0) {newval = max;} else {newval = 0;}
  }
//console.log ("  doToggle", shifted, val, max, "=", newval);
  //d3.event.stopPropagation();
  return newval;
}

function doToggleRel0(e) {
  state.rel0_value = doToggle(e.shiftKey, state.rel0_value, rel0_value_max);
  redrawUI();

  if (state.rel0_value == 0) {
    x.domain([dataTsLo, dataTsHi]); 
  } else {
    x.domain([0, dataTsMaxDur]); 
  }
  resetRangeDomain();

  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  // Redraw the zoomed X-axis and grid
  redrawXaxis();

  // Redraw the pruned Y-axis
  ////redrawYaxis();
  redrawYlabels();

}

function doToggleColorby(e) {
  state.colorby_value = doToggle(true, state.colorby_value, colorby_value_max);
  document.getElementById("colorby").innerHTML = ["Method", "Client", "Server"][state.colorby_value];
  decorateButton(document.getElementById("colorby"), state.colorby_value);
  document.getElementById("colorby").style.width = '65px';
  redrawEventsEtc();
}


function doToggleTitletext(e) {
  state.textmultiplier_value = doToggle(e.shiftKey, state.textmultiplier_value, 
    textmultiplier_value_max);

  // Update the entire screen 
  allocOuterSvgEtc();
}

function doToggleBasetimetext(e) {
//console.log("doToggleBasetimetext");
  state.basetime0_value = doToggle(e.shiftKey, state.basetime0_value, basetime0_value_max);
  ///state.rel0_value = doToggle(e.shiftKey, state.rel0_value, rel0_value_max);
  doToggleRel0(e);
}


//========
// Routines for initialization 

function initializeState() {
  state.filename_text = ""; 
  state.currentcolor = normalcolor;
  state.cb_value = 0; 			// do not show colorblind by default
  state.rel0_value = 0; 		// Initially, not relative to zero
  state.colorby_value = 0; 		// Method, client, server
  state.annotateall_value = 0; 		// Off
  state.annotateuser_value = 0; 	// Off
  state.searchnot_value = 0;		// false = like grep. true = like grep -v
  state.search_text = "";
  state.usec_lo_time = 0;
  state.usec_hi_time = 0;
  state.textmultiplier_value = 0;
  state.basetime0_value = 0;

  // For the four groups = Cpu, Pid, Rpc, Res(ource)
  state.grouplength = [0, 0, 0, 0];
  state.groupcompress = [3, 0, 0, 0]; 		// Show CPUs, collapse others
  state.grouplabelypos = [0, 0, 0, 0];		// In pixels, for expand/compress place 
  state.groupfirsttrack = [0, 0, 0, 0]; 	// Label track number for expand/compress place

  // X-axis and Y-axis scaling
  state.savedtransformX = d3.zoomIdentity;
  state.savedtransformY = d3.zoomIdentity;

  // Highlighted events and their rows
  state.hilite_event_set = new Set();
  state.hilite_row_set = new Set();
  state.fullsize_row_set = new Set();		// has at least one highlighted event

  // NOTE = save/restore does not work for sets. Sigh.
  // So instead we move sets into these arrays around save/restore
  state.hilite_event_array = [];
  state.hilite_row_array = [];
  state.fullsize_row_array = [];

  // List of items that are annotated on screen
  state.annotated_d = [];

  // Single item annotated even across pan/zoom
  state.annotated_one_d = -1;
}

// fraction3 is [percentage, minimum, maximum]
function calcfraction(total, fraction3) {
  var temp = Math.round(total * fraction3[0] / 100);
  if (fraction3[1] != 0) {temp = Math.max(temp, fraction3[1]);}
  if (fraction3[2] != 0) {temp = Math.min (temp, fraction3[2]);}
  return temp;
}

function allocOuterSvg() {
  winWidth = window.innerWidth;
  winHeight = window.innerHeight;
  var txtmul = textmultiplier_tbl[state.textmultiplier_value];

  // Leave approximate room for Regions 0 and 6 (HTML lines)
  svgWidth = winWidth - (winMargin2.left + winMargin2.right);
  svgHeight = winHeight - (winMargin2.top + winMargin2.bottom);
  if (winWidth < winMargin2.width1) {
    // Make room for two lines at top and two at bottom if narrow window
    svgHeight = winHeight - (winMargin2.top2x + winMargin2.bottom2x);
  }
console.log("winWidth", winWidth, "winHeight", winHeight);
console.log("svgWidth", svgWidth, "svgHeight", svgHeight);

  // TEMP: Running comment
  document.getElementById("matchcount").innerHTML = svgWidth + "x" + svgHeight;

  // Remove any existing outersvg and all its contents
  d3.select("svg").remove() ;
 
  // Allocate new one
  outersvg = d3.select("span#anchorsvg").append("svg")
    .attr("class", "svgtop")
    .attr("width", svgWidth)
    .attr("height", svgHeight);

  // For tall narrow windows, scale labels by width, not height
  var tempheight = Math.min(svgHeight, svgWidth);
  region1height = Rnd0(txtmul * calcfraction(tempheight, region1paramH));
  region5height = Rnd0(txtmul * calcfraction(tempheight, region5paramH));
  region234height = svgHeight - region1height - region5height; 
console.log("region 1 234 5 heights =", region1height, region234height, region5height);

  // region1width = svgWidth;
  region2width = Rnd0(txtmul * calcfraction(svgWidth, region2paramW));
  region4width = Rnd0(calcfraction(svgWidth, region4paramW));
  region3width = svgWidth - region2width - region4width; 
  // Allow some slop room for labels and timelines to hang out into region4
  region3clipwidth = region3width + (region4width / 2); 
  // region5width = svgWidth;
console.log("region 2 3 4 widths =", region2width, region3width, region4width);

  // Set up matching text sizes
  // Title text size is 0.9 * region1height, which in turn is function of textmultiplier 
  // X-axis text size is 0.9 * region5height / 2
  // Small X-axis text size is 0.75 * region5height / 2
  // Annotation text size is ... Figure 16 CPU lines + 4 group labels + 1 or so = 21
  //  lines in 80% of the height, so each line is about 4% of the height
  //  we want lines of small text to fit into half this 

  textsize.title = Rnd0(0.9 * region1height);
  textsize.label = Math.max(28, Rnd0(0.9 * region5height / 2));
  textsize.tick  = Math.max(28, Rnd0(0.75 * region5height / 2));
  textsize.smalltick = Math.max(28, Rnd0(0.55 * region5height / 2));

  titlePx =  textsize.title + "px";
  axisLabelPx =  textsize.label + "px";
  axisTickPx =  textsize.tick + "px";
  axisSmallTickPx = textsize.smalltick + "px";

  // TEMP show outer SVG with very light green
  //outersvg.append("rect")
  //  .attr("width", "100%")
  //  .attr("height", "100%")
  //  .attr("fill", "#FFFFF8");	// very light yellow

  // TEMP: Show the origin with (quarter) green circle
  //outersvg.append("circle")
  //  .attr("cx", 0)
  //  .attr("cy", 0)
  //  .attr("r", 7)
  //  .attr("fill", "green");
//console.log("  green circle should be showing");

  // The outer SVG has an offset group to contain all its children
  svgdotg =  outersvg.append("g")
    .on("mousedown", mousedown_x)
    .on("mouseup", mouseup_x)
    .attr("class", "svgdotg")
    .attr("transform", "translate(" + region2width + "," + region1height + ")");

  // And within outer, the inner SVG, aka Region 3
  innersvg = svgdotg.append("svg")
   .attr("class", "region3")
    .attr("width", region3clipwidth)  // Allow room for labels to hang out right
    ////.attr("width", region3width)  
    .attr("height", region234height);

  // And that inner SVG has a group to contain all its children
  // We catch mouse events in it also, for annotate
  innersvgdotg = innersvg.append("g");

  // TEMP: show innersvg with light red/gray
  //innersvgdotg.append("rect")
  //  .attr("width", region3width)
  //  .attr("height", region234height)
  //  .attr("fill", "#FFF0F0");	// light red/gray


  // And within outer, an SVG area for Region 2
  region2 = svgdotg.append("svg")	// We want clipping to this rectangle
    .attr("class", "region2")
    .attr("x", -region2width)
    .attr("y", 0)
    .attr("width", region2width)
    .attr("height", region234height);

 // And within that, a group for Region 2
  region2dotg = region2.append("g"); 


  // And within outer, a group for Region 4
  region4 = svgdotg.append("g")
    .attr("class", "region4")
    .attr("x", region3width)
    .attr("y", 0)
//    .attr("fill", "#FFE0FF")		// TEMP magenta (change "g" to "rect" to see)
    .attr("width", region4width)
    .attr("height", region234height);

  // And within outer, a group for Region 5
  region5 = svgdotg.append("g")
    .attr("class", "region5")
    .attr("x",  -region2width)
    .attr("y", region234height)
//    .attr("fill", "#FFFFE0")		// TEMP yellow (change "g" to "rect" to see)
    .attr("width", svgWidth)
    .attr("height", region5height);

   // Show the base point in red (green if colorblind toggle is 1)
  reddot = svgdotg.append("circle")
    .attr("id", "reddot")
           .attr("cx", 0)
           .attr("cy", region234height)
           .attr("r", 7)
           .attr("fill", "red");
  // Set listener for red dot
  reddot.on("click", resetzoom);

//console.log("  red circle should be showing");
}

// Button is unavailable if val < 0
// Button is inactive if val == 0
// Button is active if val >= 0
function decorateButton(elem, val) {
  if (val > 0) {
    // active
    elem.style="background-color: rgb(240,240,255); color: rgb(0,0,0); border-color: rgb(0,0,255); border-radius:6px";
  } else if (val == 0) {
    // inactive
    elem.style="background-color: rgb(255,255,255); color: rgb(0,0,0); border-color: rgb(192,192,192); border-radius:6px";
  } else {
    // unavailable
    elem.style="background-color: rgb(255,255,255); color: rgb(224,224,224); border-color: rgb(224,224,224); border-radius:6px";
  }
}


function fillOuterSvg() {
  // Add the graph title centered over region3
  // 0.8 is approximation that shifts up to allow descenders
  outersvg.append("text") 
      .attr("id", "titletext")            
      .attr("transform", "translate(" + (region2width + region3width/2) + ", " + 
                                    (0.8 * region1height) + ")")
      .attr("font-size", (textsize.title) + "px")
      .attr("font-family", "serif")
      .attr("class", "title-text noselect")
      .style("text-anchor", "middle")
      .style("fill", "blue")
      .text(data.title);

  var xaxisHeight = region5height / 2;


  // basetime 
  outersvg.append("text") 
      .attr("id", "basetimetext")            
      .attr("transform", "translate(" + (0) + ", " +
            (svgHeight - 0.1 * xaxisHeight) + ")")
      .attr("width", svgWidth)
      .attr("font-size", (textsize.tick) + "px")
      .attr("font-family", "sans-serif")
      .attr("class", "noselect")
      .style("text-anchor", "start")
      .style("fill", "black")
      .text("");				// placeholder

  // X-axis label
  outersvg.append("text")  
      .attr("id", "xaxislabel")           
      .attr("transform", "translate(" + (svgWidth/2) + ", " +
            (svgHeight - 0.1 * xaxisHeight) + ")")
      .attr("font-size", (textsize.label) + "px")
      .attr("font-family", "serif")
      .attr("class", "title-text noselect")
      .style("text-anchor", "middle")
      .style("fill", "blue")
      //.text(data.axisLabelX);		
      .text("");				// placeholder		


  // Set listeners for text areas
  document.getElementById("titletext").addEventListener("click", doToggleTitletext);
  document.getElementById("basetimetext").addEventListener("click", doToggleBasetimetext);

  // document.getElementById("moretoggle").addEventListener("click", doToggleMore);
}




// Re-allocate outer SVG as function of browser window, and 
// redraw everything inside as function of state, data
function allocOuterSvgEtc() {
//console.log("3 state.savedtransformY", state.savedtransformY);

  allocOuterSvg();
  fillOuterSvg();
  redrawUI();
		
  // Renumber the track heights per row, to auto-prune rows no longer visible
  // No update of y.domain here -- not created yet

  state.rel0_value = 0;
  decorateButton(document.getElementById("relzero"), state.rel0_value);
  calculateRowTracks();
  setInitialRangeDomain();

  redrawEventsEtc();

  // Axes depend on calculateBasetime in redrawEventsEtc
  drawInitialXaxis();
  drawInitialYaxis();
  drawInitialPanZoom();
  redrawYlabels();


//console.log("5 state.savedtransformY", state.savedtransformY);
}

// Start over with new data but old window
function newdataEtc(mydata) {
  newdata2(mydata);

  allocOuterSvgEtc();
}

// Start over with new window size but old data, if any
function resizeWindowEtc() {
  allocOuterSvgEtc();
}


//----------------------------------------------------------------------------//
// Initialization function definition                                         //
//----------------------------------------------------------------------------//

function initAll() {
  // Initialize button values and other state
  initializeState();
 
  // Set listener for buttons
  document.getElementById("relzero").onclick = doToggleRel0;
  document.getElementById("colorby").onclick = doToggleColorby;
  document.getElementById("annotateall").onclick = annotateall;
  document.getElementById("searchnot").onclick = searchnot;

  // Set listener for windowsize
  window.addEventListener("resize", resizewindow);

  // Load initial data, if any
  if (typeof(myString) !== 'undefined') {
    var data2 = JSON.parse(myString);
    newdata2(data2);
  }

  // Use the initial window size to calculate svg size
  resizeWindowEtc();
}
</script>
 
</head>
 
 
 
<body onload="initAll()">
File: <input name="FileName" type="text" maxlength="256" id="FileName" class="Filename" onkeyup="keyupFile(event)" style="width: 150px"/> 
<!-- trace_hello_world_small.json for example -->

color:
<button id="colorby"; style="background-color:#FFFFFF; color:#000080; borderColor:#0000FF; border-radius:6px; width:65px;">Method</button>

<button id="relzero"; style="background-color:#FFFFFF; color:#000080; borderColor:#0000FF; border-radius:6px";>Rel. 0</button>

<button id="annotateall"; style="background-color:#FFFFFF; color:#808080; borderColor:#C0C0C0; border-radius:6px";>Annotate</button>


search: 
<button id="searchnot"; style="background-color:#FFFFFF; color:#808080; borderColor:#C0C0C0; border-radius:6px";>!</button>
<input name="SearchText" type="text" maxlength="256" id="SearchText" class="Searchtext" onkeyup="keyupSearch(event)" style="width: 150px; background-color:#FFFFFF"/> 

usec:
<input name="SearchMin" type="text" maxlength="20" id="SearchMin" class="Searchmin" onkeyup="keyupSearchMin(event)" style="width: 30px; background-color:#FFFFFF"/> 
..
<input name="SearchMax" type="text" maxlength="20" id="SearchMax" class="Searchmax" onkeyup="keyupSearchMax(event)" style="width: 30px; background-color:#FFFFFF"/>


Matches: 
<span id="matchcount"></span>
<br>

<!-- All the drawing is done in an SVG element allocated inside here -->
<span id="anchorsvg"></span><br>
 
<div>
</div>
 
<script>
 
// Main JavaScript program
// Wait for a file name keyup = CR

<!-- selfcontained2 -->

</script>
</body>
</html>
 
 

